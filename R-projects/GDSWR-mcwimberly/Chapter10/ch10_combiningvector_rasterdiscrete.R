# COMBINING VECTOR DATA WITH DISCRETE RASTER DATA
# The Cropland Data Layer is a categorical raster dataset that maps agricultural land use in the United States.
# The National Hydrographic Dataset (HND) contains vector data on the water drainage network of the US
library(tidyverse)
library(sf)
library(terra)
library(scales)
library(colorspace)
library(ggspatial)
source("rasterdf.R")

# Read in the data
crop2010 <- rast("CDL_2010_clip.tif")
crop2020 <- rast("CDL_2020_clip.tif")
streams <- st_read("NHDFlowline.shp", quiet = TRUE)
wsheds <- st_read("WBDHU10.shp", quiet = TRUE)
subwsh <- st_read("WBDHU12.shp", quiet = TRUE)

# Before trying to combine vector n raster data, it is important to check their CRS

# The NHD data are in a geographic coordinate system
writeLines(st_crs(wsheds)$WktPretty)

# The CDL data are in a projected coordinate system
writeLines(st_crs(crop2010)$WktPretty)

# The 3 vector datasets are reprojected to match the resolution of the raster data
wsheds_aea <- st_transform(wsheds, crs(crop2010))
subwsh_aea <- st_transform(subwsh, crs(crop2010))
streams_aea <- st_transform(streams, crs(crop2010))

# Visualizing and Manipulating Vector Data
wsheds_aea <- cbind(wsheds_aea, 
                    st_coordinates(st_point_on_surface(wsheds_aea)))

# Generate a labelled map of watersheds
ggplot(data = wsheds_aea) +
  geom_sf(color = "black",     #plot the watershed boundaries
          size = 0.1) +
  geom_text(aes(x = X,         #write the name of each watersheds at its label points
                y = Y, 
                label = name),
            size = 3, 
            fontface = "bold") +
  coord_sf() +
  theme_void()

# Some labels are difficult to read and due to the complex shape of the watersheds, 
# the point locations generated by st_point_on.. are not well centered
# It is often possible to manually adjust the placement of the texts
# This is the order of the watersheds in the df:
wsheds$name

# To adjust the label placement for some of the watersheds:
hnudge <- c(-10000, 5000, 0, 0, 0, 0, 0, 0, 0, 0, 0)   # these values are in map units which in this case are in metres
vnudge <- c(-7500, 2500, 0, 0, 0, 0, 0, 0, 0, 5000, 0)

ggplot(data = wsheds_aea) +
  geom_sf(color = "black",
          size = 0.1) +
  geom_text(aes(x = X,
                y = Y, 
                label = name),
            nudge_x = hnudge,
            nudge_y = vnudge,
            size = 3, 
            fontface = "bold") +
  theme_void()

# The label positions can also be adjusted using an alternative geom
# str_wrap forces the label to wrap so that the max width is 15 characters
ggplot(data = wsheds_aea) +
  geom_sf(color = "black",
          size = 0.1) +
  geom_spatial_label_repel(aes(x = X,
                               y = Y, 
                               label = str_wrap(name, 15)),
                           size = 3, 
                           fontface = "bold",
                           crs = st_crs(wsheds_aea)) +
  theme_void()

# To include watershed boundaries as well as the nested subwatershed boundaries in dark gray
# Using annotation_scale to add scale bar
ggplot() +
  geom_sf(data = subwsh_aea, color = "darkgray") +
  geom_sf(data = wsheds_aea, color = "black", fill = NA) +
  annotation_scale(location = 'bl') +
  theme_void()

# The ffg analysis will focus on the North Deer Creek watershed
# To extract the boundary for this watershed, use the filter function
# A second filter with a nested st_covered_by to make a spatial query that selects all
# subwatershed polygons in the subwsh_aea layer that fall within the NDC watershed area
wshed_ndc <- wsheds_aea %>%
  filter(name == "North Deer Creek")

subwsh_ndc <- subwsh_aea %>%
  filter(lengths(st_covered_by(., wshed_ndc)) > 0)

# ZONAL SUMMARIES OF DISCRETE RASTER DATA

# To summarize the crop type data for each subwatershed, 
# the CDL data are first cropped n masked to the boundaries of the North Deer Creek watershed
cdlstack <- c(crop2010, crop2020)
names(cdlstack) <- c("2010", "2020")

cdl_crop <- crop(cdlstack, vect(subwsh_ndc))
subwsh_msk <- rasterize(vect(subwsh_ndc), cdl_crop)
cdl_mbs <- mask(cdl_crop, subwsh_msk)

# Reclassify the CDL into a smaller number of classes 
oldclas <- c(1, 5, 37, 176, 195)
newclas <- c(1, 2, 3, 3, 3)
lookup <- data.frame(oldclas, newclas)
cdl_rc <- classify(cdl_mbs, 
                   rcl = lookup,
                   others = 4)   # combine all the other codes into a single class(4)

# The reclassified rasters are then plotted with the subwatershed boundaries overlaid
newnames <- c("Corn",
              "Soybeans",
              "Grass",
              "Other")
newcols <- c("yellow", 
             "green", 
             "tan", 
             "gray60")
newcols2 <- desaturate(newcols, 
                       amount = 0.2)
cdl_df <- rasterdf(cdl_rc)

ggplot(data = cdl_df) +
  geom_raster(aes(x = x, 
                  y = y, 
                  fill = 
                    as.character(value))) + 
  scale_fill_manual(name = "Crop Type",
                    values = newcols2,
                    labels = newnames,
                    na.translate = FALSE) +
  geom_sf(data = subwsh_ndc,
          fill = NA) +
  facet_wrap(facets = vars(variable), ncol = 2) +
  theme_void() +
  theme(strip.text.x = element_text(size=12, face="bold"))

# To summarize discrete data where we want to estimate the areas of different classes 
# within each polygons. We start by rasterizing the subwatershed polygons to match 
# the raster grid of the landcover data. Then crosstab is used to calculate the no of cells
# of each landcover type within each subwatershed polygon
subwsh_r <- rasterize(vect(subwsh_ndc), 
                      cdl_rc, 
                      field = "ObjectID")
cdlsum10 <- crosstab(c(subwsh_r, cdl_rc[["2010"]]))
cdlsum10 <- as_tibble(cdlsum10)
cdlsum20 <- crosstab(c(subwsh_r, cdl_rc[["2020"]]))
cdlsum20 <- as_tibble(cdlsum20)

# Using a series of dplyr and tidyr commands, we convert the crosstab results into long format for mapping
# and then compute the percent area of each crop type in each subwatershed 

# Use inner_join to join the datasets
cdljoin <- cdlsum10 %>%
  inner_join(cdlsum20,
             by = c("ObjectID" = "ObjectID",
                    "X2010" = "X2020")) 
cdljoin

# Use mutate to assign actual labels in a new croptype column that is a 
# factor with labels for each of the croptype name
cdljoin2 <- cdljoin %>%
  mutate(croptype = factor(X2010,
                           labels = newnames),
         ObjectID = as.numeric(ObjectID)) %>%
  select(-X2010) %>%           # drop old column
  rename("cnt2010" = "n.x",    # rename columns
         "cnt2020" = "n.y")
cdljoin2

# The pivot_longer is used to combine the 2010 n 2020 cell counts into a single cnt column
# with year information in the year column. Use parse_number to convert year from character to numeric
cdlpivot <- cdljoin2 %>%
  pivot_longer(cols = starts_with("cnt"),
               names_to = "year",
               values_to = "cnt") %>%
  mutate(year = parse_number(year)) 
cdlpivot

# The total number of pixels for each combination of subwatershed and year is summed
# and the percent area of each crop type within each subwatershed is calculated
cdlperc <- cdlpivot %>%
  group_by(ObjectID, year) %>%
  mutate(tot = sum(cnt),
         perc_crop = 100 * cnt / tot)
cdlperc

# Note that the same code can be implemented more concisely as a single block of piped functions
# cdlperc <- cdlsum10 %>%
#   inner_join(cdlsum20,
#              by = c("ObjectID" = "ObjectID",
#                     "X2010" = "X2020")) %>%
#   mutate(croptype = factor(X2010,
#                            labels = newnames),
#          ObjectID = as.numeric(ObjectID)) %>%
#   rename("cnt2010" = "n.x",
#          "cnt2020" = "n.y") %>%
#   pivot_longer(cols = starts_with("cnt"),
#                names_to = "year",
#                values_to = "cnt") %>%
#   mutate(year = parse_number(year)) %>%
#   group_by(ObjectID, year) %>%
#   mutate(tot = sum(cnt),
#          perc_crop = 100 * cnt / tot)

# The resulting table can be joined to the dataframe containing the subwatershed polygons 
# and used to map the percent of each croptype by subwatershed in 2010 and 2020
subwsh_perc <- left_join(subwsh_ndc, 
                         cdlperc, 
                         by = "ObjectID")

ggplot(data = subwsh_perc) +
  geom_sf(aes(fill = perc_crop)) +
  scale_fill_distiller(name="Percent", 
                       palette = "YlGn", 
                       breaks = pretty_breaks(),
                       direction = 1) +
  facet_wrap(year ~ croptype, # year(row) x croptype(column)
             ncol = 4) +
  theme_void() +
  theme(strip.text.x = element_text(size=12, face="bold"))

# SUMMARIZING LANDCOVER WITH STREAM BUFFERS
# The NHD streamlines data are read in with Z coordinates 
# and they need to be converted to 2D before we can work with them
# Use st_intersection to clip the streams to the NDC boundary
streams_aea <- st_zm(streams_aea)
streams_ndc <- st_intersection(streams_aea, wshed_ndc)

ggplot() +
  geom_sf(data = subwsh_ndc, 
          color = "black", 
          size = 1) +
  geom_sf(data = streams_ndc, 
          color = "blue") +
  theme_void()

# Compute stream buffers with st_buffer - the output contains a separate buffer for each line segment in the stream network
streams_buff <- st_buffer(streams_ndc, dist = 100)

ggplot() +
  geom_sf(data = wshed_ndc, 
          color = "black", 
          size = 1) +
  geom_sf(data = streams_buff, 
          color = "blue") +
  theme_void()

# st_union to combine the separate buffer polygon into a single polygon
# Note that st_union creates a sf geometry list column(sfc) that needs to be converted 
# into an sf object before undertaking further analysis
streams_comb <- st_union(streams_buff)
class(streams_comb)

streams_comb <- st_sf(streams_comb)
class(streams_comb)

# Where streams are close to the watershed boundary, their buffers may extend outside of the watershed
riparian <- st_intersection(streams_comb, wshed_ndc)  # create a polygon encompassing all stream buffers within the NDC watershed polygon
upland <- st_difference(wshed_ndc, streams_comb)   # creates a polygon encompassing parts of the NDC watershed that are outside the stream buffers

# Stream buffers can be mapped as polygon boundaries overlaid on top of the reclassified landcover dataset
ggplot(data = cdl_df) + 
  geom_raster(aes(x = x, 
                  y = y, 
                  fill = as.character(value))) + 
  scale_fill_manual(name = "Land cover",
                    values = newcols2,
                    labels = newnames,
                    na.translate = FALSE) +
  facet_wrap(facets = vars(variable), ncol = 2) +
  geom_sf(data = streams_comb, 
          color = "darkblue", 
          fill = NA) +
  coord_sf(expand = F) +
  theme_void() +
  theme(strip.text.x = element_text(size=12, face="bold"))

# Mask the CDL raster by the rasterized riparian and upland data
riparian_mask <- rasterize(vect(riparian), cdl_rc)
cdl_rip <- mask(cdl_rc, riparian_mask)
upland_mask <- rasterize(vect(upland), cdl_rc)
cdl_up <- mask(cdl_rc, upland_mask)

# Compute the pixel counts in the resulting riparian and upland raster datasets
freq_rip <- as_tibble(freq(cdl_rip))
freq_rip

freq_up <- as_tibble(freq(cdl_up))
freq_up

# Combine the riparian and upland data and perform operations to add columns
# Using mutate to replicate the result of a summary in this case the sum() function
# for each record within a group rather than returning a single value for each group
# Calculating the percent cover of each class
cdl_chng <- freq_rip %>%
  bind_rows(freq_up) %>%
  mutate(landtype = c(rep("Riparian", 8), rep("Upland", 8)),
         year = factor(layer,
                       labels = c("2010", "2020")),
         croptype = factor(value,
                           labels = newnames)) %>%
  select(-layer, -value) %>%
  group_by(landtype) %>%
  mutate(totarea = sum(count),
         percarea = 100 * count / totarea)
cdl_chng

# Barchart to compare the distribution of croptypes by year and by riparian/upland landscape zone
# We can see from the chart that riparian areas have more grass cover than upland areas
# However the area of grass cover has decreased in both riparian and upland areas btw 2010 and 2020
ggplot(data = cdl_chng) +
  geom_bar(aes(y = percarea, 
               x = year, 
               fill = croptype),
           color = "black",
           position = "dodge",
           stat = "identity")  +
  scale_fill_manual(name = "Land Cover", 
                    values = newcols) +
  facet_wrap(facets = vars(landtype), 
             ncol = 2) +
  labs(x = "Landscape Zone", 
       y = "% Area") +
  theme_bw()

# Summarizing Land Cover with Point Buffers
# For this example, a set of 20 random points is generated within the NDC dataset
# st_sample generates an sfc object that must be converted to sf object
set.seed(32145)
plots <- st_sample(wshed_ndc, size = 20)
class(plots)

plots <- st_as_sf(plots)
class(plots)

# The location of these plots are plotted on top of the crop type data
ggplot(data = cdl_df) + 
  geom_raster(aes(x = x, y = y, fill = as.character(value))) + 
  scale_fill_manual(name = "Land cover",
                    values = newcols2,
                    labels = newnames,
                    na.translate = FALSE) +
  geom_sf(data = plots, fill = NA) +
  facet_wrap(facets = vars(variable)) +
  coord_sf(expand = F) +
  theme_void() +
  theme(strip.text.x = element_text(size=12, face="bold"))

# Create a buffer of 200m around each point
st_geometry_type(plots, by_geometry = FALSE)
plot_poly <- st_buffer(plots, dist = 200)
st_geometry_type(plot_poly, by_geometry = FALSE)

# To summarize the percent cover of each land cover class within a buffer around each point, 
# the segregate() function is used to convert the classified raster data into a stack of indicator (1, 0) rasters. 
cdl_stk <- segregate(cdl_rc[["2020"]])
names(cdl_stk) <- newnames

# The resulting df has one row for each plot and one column for each crop type
plots_cdl <- extract(cdl_stk,
                     vect(plot_poly), 
                     fun = mean, 
                     na.rm = T)

# Convert to a long format
plots_long <- plots_cdl %>%
  pivot_longer(Corn:Other, 
               names_to = "croptype", 
               values_to = "percarea")
plots_long

# The distribution of crop type proportions within the plot buffer can be visualized
ggplot(data = plots_long) +
  geom_boxplot(aes(x = croptype, 
                   y = percarea)) +
  xlab("Land Cover Class") +
  ylab("Cover Proportion") +
  theme_bw()

