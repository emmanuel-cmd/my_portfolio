
// Intrepreting timeseries with CCDC
var utils = require('users/parevalo_bu/gee-ccdc-tools:ccdcUtilities/api');

// We will obtain an ImageCollection of Landsat 4,
// 5, 7, and 8 data (Collection 2 Tier 1) that has been filtered for clouds, 
// cloud shadows, haze, and radiometrically saturated pixels.
// We will use the function getLandsat included in the inputs module of our utilities

// the getLandsat function will retrieve all surface reflectance bands
// as well as other vegetation indices. To simplify the exercise, we'll 
// select only the surface reflectance bands we are going to use:

var studyRegion = ee.Geometry.Rectangle([
    [-63.9533, -10.1315],
    [-64.9118, -10.6813]
]);

// Define start, end dates and Landsat bands to use.
var startDate = '2000-01-01';
var endDate = '2020-01-01';
var bands = ['BLUE', 'GREEN', 'RED', 'NIR', 'SWIR1', 'SWIR2'];

// Retrieve all clear, Landsat 4, 5, 7 and 8 observations (Collection 2, Tier 1).
var filteredLandsat = utils.Inputs.getLandsat({
    collection: 2
  })
    .filterBounds(studyRegion)
    .filterDate(startDate, endDate)
    .select(bands);
    
print(filteredLandsat.first()); 

// Set CCD params to use.
var ccdParams = {
    breakpointBands: ['GREEN', 'RED', 'NIR', 'SWIR1', 'SWIR2'],
    tmaskBands: ['GREEN', 'SWIR2'],
    minObservations: 6,  // the number of consecutive observations required to flag a change
    chiSquareProbability: 0.99, //the sensitivity of the algorithm to detect change 
    minNumOfYearsScaler: 1.33, // and the iterative curve fitting process required to detect change
    dateFormat: 1,  // corresponds to fractional years
    lambda: 0.002,
    maxIterations: 10000, // lambda n maxIterations control the curve fitting process
    collection: filteredLandsat // specify the imagecollection to use
};
// Run CCD.
var ccdResults = ee.Algorithms.TemporalSegmentation.Ccdc(ccdParams);
print('ccdResults:', ccdResults);

// The process of running the algorithm interactively for more than a handful of pixels can become very taxing to the system
// very quickly, resulting in memory errors. To avoid having such issues, we typically
// export the results to an Earth Engine asset first, and then inspect the asset. This
// approach ensures that CCDC completes its run successfully, and also allows us to
// access the results easily later


// The code required to export CCDC results is shown below
var exportResults = false
if (exportResults) {
    // Create a metadata dictionary with the parameters and arguments used.
    var metadata = ccdParams;
    metadata['breakpointBands'] = metadata['breakpointBands'].toString();
    metadata['tmaskBands'] = metadata['tmaskBands'].toString();
    metadata['startDate'] = startDate;
    metadata['endDate'] = endDate;
    metadata['bands'] = bands.toString();
    // Export results, assigning the metadata as image properties.
    Export.image.toAsset({
      image: ccdResults.set(metadata),
      region: studyRegion,
    pyramidingPolicy: {
      ".default": 'sample'
    },
      scale: 30
    });
} 

// Section 3: Extracting Break Information
// We will now explore the pre-computed CCDC results 
var palettes = require('users/gena/packages:palettes');
var resultsPath = 'projects/gee-book/assets/F4-7/Rondonia_example_small';
var ccdResults = ee.Image(resultsPath);

Map.centerObject(ccdResults, 10);
print(ccdResults); 

// Select time of break and change probability array images.
var change = ccdResults.select('tBreak');
var changeProb = ccdResults.select('changeProb');
print('change:', change);
print('changeProb:', changeProb);

// Set the time range we want to use and get as mask of
// places that meet the condition.
var start = 2000;
var end = 2021;
var mask = change.gt(start).and(change.lte(end)).and(changeProb.eq(1));
Map.addLayer(changeProb, {}, 'change prob');

// Obtain the number of breaks for the time range.
var numBreaks = mask.arrayReduce(ee.Reducer.sum(), [0]);
Map.addLayer(
  numBreaks, 
  {
    min: 0,
    max: 5
  }, 
  'Number of breaks'
);

// For places with many changes, visualizing the first or last time when a break
// was recorded can be helpful to understand the change dynamics happening in the
// landscape.

// Obtain the first change in that time period.
var dates = change.arrayMask(mask).arrayPad([1]); // we fill or pad those pixels that do not experience any change
var firstChange = dates
    .arraySlice(0, 0, 1)   // select the first value in the array
    .arrayFlatten([['firstChange']]) // convert img from 1 dimensional img to a regular img
    .selfMask();

var timeVisParams = {
    palette: palettes.colorbrewer.YlOrRd[9],
    min: start,
    max: end
};

Map.addLayer(firstChange, timeVisParams, 'First change');

// Obtain the last change in that time period.
var lastChange = dates
    .arraySlice(0, -1) // select the last value in the array
    .arrayFlatten([['lastChange']]) // convert img from 1 dimensional img to a regular img
    .selfMask();

Map.addLayer(lastChange, timeVisParams, 'Last change');

// We can use the magnitude bands to visualize where and when the largest
// changes as recorded by CCDC have occurred, during our selected time period.

// Get masked magnitudes.
var magnitudes = ccdResults
    .select('SWIR1_magnitude')
    .arrayMask(mask)
    .arrayPad([1]);

// Get index of max abs magnitude of change.
var maxIndex = magnitudes
    .abs()
    .arrayArgmax()
    .arrayFlatten([['index']]);

// Select max magnitude and its timing
var selectedMag = magnitudes.arrayGet(maxIndex);
var selectedTbreak = dates.arrayGet(maxIndex).selfMask();
var magVisParams = {
    palette: palettes.matplotlib.viridis[7],
    min: -0.15,
    max: 0.15
};

Map.addLayer(selectedMag, magVisParams, 'Max mag');
Map.addLayer(selectedTbreak, timeVisParams, 'Time of max mag');