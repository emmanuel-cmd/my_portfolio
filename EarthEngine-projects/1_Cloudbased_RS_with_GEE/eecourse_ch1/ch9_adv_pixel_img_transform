// Section 1: Manipulating images with expression
// Arithmetic calculation of EVI

// Import and filter imagery by location and date.
var sfoPoint = ee.Geometry.Point(-122.3774, 37.6194);
var sfoImage = ee.ImageCollection('COPERNICUS/S2')
.filterBounds(sfoPoint)
.filterDate('2020-02-01', '2020-04-01')
.first();

Map.centerObject(sfoImage, 11);

// Calculate EVI using Sentinel 2
// Extract the bands and divide by 10,000 to account for scaling done.
var nirScaled = sfoImage.select('B8').divide(10000);
var redScaled = sfoImage.select('B4').divide(10000);
var blueScaled = sfoImage.select('B2').divide(10000);

// Calculate the numerator, note that order goes from left to right.
var numeratorEVI = (nirScaled.subtract(redScaled)).multiply(2.5);

// Calculate the denominator.
var denomClause1 = redScaled.multiply(6);
var denomClause2 = blueScaled.multiply(7.5);
var denominatorEVI = nirScaled.add(denomClause1)
.subtract(denomClause2).add(1);

// Calculate EVI and name it.
var EVI = numeratorEVI.divide(denominatorEVI).rename('EVI');

// And now map EVI using our vegetation palette.
var vegPalette = ['red', 'white', 'green'];
var visParams = {min: -1, max: 1, palette: vegPalette};
Map.addLayer(EVI, visParams, 'EVI');

// Using an expression to calculate EVI
// In another simple strategy, Earth Engine has a way to define 
// an expression to achieve the same result

// Calculate EVI.
var eviExpression = sfoImage.expression({
    expression: '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))',
    map: { // Map between variables in the expression and images.
    'NIR': sfoImage.select('B8').divide(10000),
    'RED': sfoImage.select('B4').divide(10000),
    'BLUE': sfoImage.select('B2').divide(10000)
    }
});
// And now map EVI using our vegetation palette.
Map.addLayer(eviExpression, visParams, 'EVI Expression');

// Using an expression to calculate BAI (Burned Area Index)
// Examine the true-color Landsat 8 images for the 2013 Rim Fire.
var burnImage = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')
.filterBounds(ee.Geometry.Point(-120.083, 37.850))
.filterDate('2013-09-15', '2013-09-27')
.sort('CLOUD_COVER')
.first();

Map.centerObject(ee.Geometry.Point(-120.083, 37.850), 11);

var rgbParams = {
    bands: ['B4', 'B3', 'B2'],
    min: 0,
    max: 0.3
};

Map.addLayer(burnImage, rgbParams, 'True-Color Burn Image');

// Calculate BAI.
var bai = burnImage.expression(
    '1.0 / ((0.1 - RED)**2 + (0.06 - NIR)**2)', {
    'NIR': burnImage.select('B5'),
    'RED': burnImage.select('B4'),
});

// Display the BAI image.
var burnPalette = ['green', 'blue', 'yellow', 'red'];
Map.addLayer(bai, {
    min: 0,
    max: 400,
    palette: burnPalette
}, 'BAI');

// Section II: Manipulating images with matrix algebra

/////
// Manipulating images with matrices
/////

// Let us create a new script and make an array of TC coefficients for Landsat
// 5’s Thematic Mapper (TM) instrument

// Begin Tasseled Cap example.
var landsat5RT = ee.Array([
    [0.3037, 0.2793, 0.4743, 0.5585, 0.5082, 0.1863],
    [-0.2848, -0.2435, -0.5436, 0.7243, 0.0840, -0.1800],
    [0.1509, 0.1973, 0.3279, 0.3406, -0.7112, -0.4572],
    [-0.8242, 0.0849, 0.4392, -0.0580, 0.2012, -0.2768],
    [-0.3280, 0.0549, 0.1075, 0.1855, -0.4357, 0.8085],
    [0.1084, -0.9022, 0.4120, 0.0573, -0.0251, 0.0238]
]);

print('RT for Landsat 5', landsat5RT);

// Define a point of interest in Odessa, Washington, USA.
var point = ee.Geometry.Point([-118.7436019417829, 47.18135755009023]);
Map.centerObject(point, 10);

// Filter to get a cloud free image to use for the TC.
var imageL5 = ee.ImageCollection('LANDSAT/LT05/C02/T1_TOA')
    .filterBounds(point)
    .filterDate('2008-06-01', '2008-09-01')
    .sort('CLOUD_COVER')
    .first();

// Display the true-color image.
var trueColor = {
    bands: ['B3', 'B2', 'B1'],
    min: 0,
    max: 0.3
};

Map.addLayer(imageL5, trueColor, 'L5 true color');

// To do the matrix multiplication, first convert the input image 
// from a multi-band image to an array image
// An array image is a higher-dimension image in which each pixel stores an array
// of values for a band. 

// You will use bands 1–5 and 7 and the toArray function:

var bands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'];
// Make an Array Image, with a one dimensional array per pixel.
// This is essentially a list of values of length 6,
// one from each band in variable 'bands.'

var arrayImage1D = imageL5.select(bands).toArray();
print(arrayImage1D);
// Make an Array Image with a two dimensional array per pixel,
// of dimensions 6x1. This is essentially a one column matrix with
// six rows, with one value from each band in 'bands.'
// This step is needed for matrix multiplication (p0).
var arrayImage2D = arrayImage1D.toArray(1);
print(arrayImage2D);
// Next, we complete the matrix multiplication of TC using the 
// matrixMultiply function & convert the result back to a 
// multi-band img using the arrayProject and arrayFlatten functions

//Multiply RT by p0.
var tasselCapImage = ee.Image(landsat5RT)
    // Multiply the tasseled cap coefficients by the array
    // made from the 6 bands for each pixel.
    .matrixMultiply(arrayImage2D)
    // Get rid of the extra dimensions.
    .arrayProject([0])
    // Get a multi-band image with TC-named bands.
    .arrayFlatten(
    [
      ['brightness', 'greenness', 'wetness',
      'fourth', 'fifth',
      'sixth'
      ]
]);

// This maps brightness to red, greenness to green, and wetness to blue.
// Water appears blue, healthy irrigated crops are the bright circles, and drier crops are red.
var vizParams = {
    bands: ['brightness', 'greenness', 'wetness'],
    min: -0.1,
    max: [0.5, 0.1, 0.1]
};

Map.addLayer(tasselCapImage, vizParams, 'TC components');

// To see how the array image operations work, consider building 
// tasselCapImage one step at a time

// var tassel = ee.Image(landsat5RT).matrixMultiply(arrayImage2D);
// Map.addLayer(tassel, {min:-0.1, max: 1}, 'Tassel');

// var tasselCap = tassel.arrayProject([0]);
// Map.addLayer(tasselCap, {min:-0.1, max: 1}, 'TasselCap');
// print('TasselCap:', tasselCap);

// var tasselCapImage = tasselCap.arrayFlatten(
//     [
//       ['brightness', 'greenness', 'wetness',
//       'fourth', 'fifth',
//       'sixth'
//       ]
// ])
// print('TasselCapImage:', tasselCapImage);

// Begin PCA example.
// Select and map a true-color L8 image.
var imageL8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')
    .filterBounds(point)
    .filterDate('2018-06-01', '2018-09-01')
    .sort('CLOUD_COVER')
    .first();
var trueColorL8 = {
    bands: ['B4', 'B3', 'B2'],
    min: 0,
    max: 0.3
};

Map.addLayer(imageL8, trueColorL8, 'L8 true color');

// Select which bands to use for the PCA.
var PCAbands = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11'];

// Convert the Landsat 8 image to a 2D array for the later matrix
// computations.
var arrayImage = imageL8.select(PCAbands).toArray();

// Map.addLayer(
//   arrayImage,
//   {
//     min: 0
//   },
//   'PCA L8 img',
//   0
// )

// Calculate the covariance using the reduceRegion method.
var covar = arrayImage.reduceRegion({
    reducer: ee.Reducer.covariance(),
    maxPixels: 1e9
});

//print(covar);

// Extract the covariance matrix and store it as an array.
var covarArray = ee.Array(covar.get('array'));

// Now that we have a covariance matrix based on the img
// we can perform an eigen analysis to compute the eigenvectors 
// that we will need to perform the PCA

//Compute and extract the eigenvectors
var eigens = covarArray.eigen();
//print('Eigens:', eigens);

// the eigen function outputs both eigenvectors and values
// Since we need the eigenvectors for the PCA, 
// we can use slice function for arrays to extract them
var eigenVectors = eigens.slice(1, 1); 
//print('EigenVectors:', eigenVectors);

// Now we perform matrix multiplication by using the eigenvectors
// and the arrayImage we created earlier

// Perform matrix multiplication
var principalComponents = ee.Image(eigenVectors)
.matrixMultiply(arrayImage.toArray(1));

// Finally convert back to a multi-band image and 
// display the first principal component (pc1):

var pcImage = principalComponents
    // Throw out an unneeded dimension, [[]] -> [].
    .arrayProject([0])
    // Make the one band array image a multi-band image, [] -> image.
    .arrayFlatten([
    ['pc1', 'pc2', 'pc3', 'pc4', 'pc5', 'pc6', 'pc7',
    'pc8']
  ]);

// Stretch this to the appropriate scale.
Map.addLayer(
  pcImage.select('pc1'), 
  {
    min:-440.2, 
    max: -423.4
  }, 
  'pc1'
); 

// The min and max values will need to change if you map different bands or locations.
var visParamsPCA = {
    bands: ['pc1', 'pc3', 'pc4'],
    min: [-455.09, -2.206, -4.53],
    max: [-417.59, -1.3, -4.18]
};

Map.addLayer(pcImage, visParamsPCA, 'PC_multi');


