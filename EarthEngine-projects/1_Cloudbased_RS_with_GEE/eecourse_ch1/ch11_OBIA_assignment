// 1.1 Unsupervised k-Means classification
// This function does unsupervised clustering classification
// input = any image. All bands will be used for clustering.
// numberOfUnsupervisedClusters = tunable parameter for how
// many clusters to create.
var afn_Kmeans = function(input, numberOfUnsupervisedClusters, defaultStudyArea, nativeScaleOfImage) {

    // Make a new sample set on the input. Here the sample
    // randomly selected spatially.
    var training = input.sample({
        region: defaultStudyArea,
        scale: nativeScaleOfImage,
        numPixels: 1000
    });
    var cluster = ee.Clusterer.wekaKMeans(numberOfUnsupervisedClusters)
    .train(training);
    // Now apply that clusterer to the raw image that was also passed in. set is
    var toexport = input.cluster(cluster);
    // The first item is the unsupervised classification. Name the band.
    var clusterUnsup = toexport.select(0).rename('unsupervisedClass');
    return (clusterUnsup);
}; 

// 1.2 Simple normalization by maxes function.
var afn_normalize_by_maxes = function(img, bandMaxes) {
    return img.divide(bandMaxes);
};

// 1.3 Seed Creation and SNIC segmentation Function
var afn_SNIC = function(imageOriginal, SuperPixelSize,
                        Compactness, Connectivity, NeighborhoodSize, SeedShape) {
    var theSeeds = ee.Algorithms.Image.Segmentation.seedGrid(SuperPixelSize, SeedShape);
    var snic2 = ee.Algorithms.Image.Segmentation.SNIC({
      image: imageOriginal,
      size: SuperPixelSize,
      compactness: Compactness,
      connectivity: Connectivity,
      neighborhoodSize: NeighborhoodSize,
      seeds: theSeeds
    });
    var theStack = snic2.addBands(theSeeds);
    return(theStack);
};

// 1.4 Simple add mean to Band Name function
var afn_addMeanToBandName = (function(i) {
    return i + '_mean';
});

////////////////////////////////////////////////////////////
// 2. Parameters to function calls
////////////////////////////////////////////////////////////
// 2.1. Unsupervised KMeans Classification Parameters
var numberOfUnsupervisedClusters = 4;

////////////////////////////////////////////////////////////
// 2.2. Visualization and Saving parameters
// For different images, you might want to change the min and max
// values to stretch. Useful for images 2 and 3, the normalized images.
var centerObjectYN = true; 

// 2.3 Object-growing parameters to change
// Adjustable Superpixel Seed and SNIC segmentation Parameters:
// The superpixel seed location spacing, in pixels.
var SNIC_SuperPixelSize = 16;

// Larger values cause clusters to be more compact (square/hexagonal).
// Setting this to 0 disables spatial distance weighting.
var SNIC_Compactness = 0;

// Connectivity. Either 4 or 8.
var SNIC_Connectivity = 4;

// Either 'square' or 'hex'.
var SNIC_SeedShape = 'square';

// 2.4 Parameters that can stay unchanged
// Tile neighborhood size (to avoid tile boundary artifacts). Defaults to 2 * size.
var SNIC_NeighborhoodSize = 2 * SNIC_SuperPixelSize;

////Image 4.6
//'Hanceville, BC:
//Fire Disturbance
//(Oct 3, 2017)'
//Modis, 250m
var originalImage = ee.Image('MODIS/006/MOD09GQ/2017_10_03');
var ImageToUseID = 'MOD09GQ2017_10_03';
// print(ImageToUseID, originalImage);
var nativeScaleOfImage = 250;
var bandsToUse = ['sur_refl_b01', 'sur_refl_b02'];
var bandMaxes = [1e4, 1e4];
var threeBandsToDraw = ['sur_refl_b02','sur_refl_b01'];
var defaultStudyArea = ee.Geometry.Polygon(
    [
        [
            [-122.9754638671875, 51.77803705914518],
            [-121.46484375, 51.529251355189906],
            [-121.4483642578125, 51.70660846336452],
            [-121.431884765625, 52.32526831457076],
            [-122.9864501953125, 52.34540753654635]
        ]
    ]);
var zoomArea = defaultStudyArea;
var drawMin = 0;
var drawMax = 1;



// Function definition

var my_function = function(originalImage, date, ImageToUseID){
  
    Map.addLayer(originalImage.select(threeBandsToDraw), {min:-100,max:5000}, '3.6 ' +
      ImageToUseID);
  
    //4.1 You can use the geometry of image to clip by using the following line:
    //var defaultStudyArea = originalImage.geometry();
    
    var clippedImageSelectedBands = originalImage.clip(defaultStudyArea)
        .select(bandsToUse);
    
    var ImageToUse = afn_normalize_by_maxes(clippedImageSelectedBands,
        bandMaxes);
    
    ////////////////////////////////////////////////////////////
    // 5. SNIC Clustering
    ////////////////////////////////////////////////////////////
    
    // This function returns a multi-banded image that has had 
    // SNIC applied to it. It automatically determines the new names 
    // of the bands that will be returned from the segmentation.
    
    //print('5.1 Execute SNIC');
    var SNIC_MultiBandedResults = afn_SNIC(
        ImageToUse,
        SNIC_SuperPixelSize,
        SNIC_Compactness,
        SNIC_Connectivity,
        SNIC_NeighborhoodSize,
        SNIC_SeedShape
    );
    
    var SNIC_MultiBandedResults = SNIC_MultiBandedResults.reproject('EPSG:3857', null, nativeScaleOfImage);
    //print('5.2 SNIC Multi-Banded Results', SNIC_MultiBandedResults);
    
    // Map.addLayer(SNIC_MultiBandedResults.select('clusters')
    //     .randomVisualizer(), {}, '5.3 SNIC Segment Clusters_' + str_id, true, 1);
    
    var theSeeds = SNIC_MultiBandedResults.select('seeds');
    // Map.addLayer(theSeeds, {
    //     palette: 'red'
    // }, '5.4 Seed points of clusters', true, 1);
    
    var bandMeansToDraw = threeBandsToDraw.map(afn_addMeanToBandName);
    // print('5.5 band means to draw', bandMeansToDraw);
    var clusterMeans = SNIC_MultiBandedResults.select(bandMeansToDraw);
    // print('5.6 Cluster Means by Band', clusterMeans);
    Map.addLayer(clusterMeans, {
        min: drawMin,
        max: drawMax
    }, '5.7 Image repainted by segments_' + date, 0, 1);
    
    ////////////////////////////////////////////////////////////
    // 6. Execute Classifications
    ////////////////////////////////////////////////////////////
    
    // 6.1 Per Pixel Unsupervised Classification for Comparison
    
    var PerPixelUnsupervised = afn_Kmeans(ImageToUse,
        numberOfUnsupervisedClusters, defaultStudyArea,
        nativeScaleOfImage);
    Map.addLayer(PerPixelUnsupervised.select('unsupervisedClass')
        .randomVisualizer(), {}, '6.1 Per-Pixel Unsupervised_' + date, 0, 1
    );
    // print('6.1b Per-Pixel Unsupervised Results:', PerPixelUnsupervised);
    
    // 6.2 SNIC Unsupervised Classification for Comparison
    
    var bandMeansNames = bandsToUse.map(afn_addMeanToBandName);
    // print('6.2 band mean names returned by segmentation', bandMeansNames);
    var meanSegments = SNIC_MultiBandedResults.select(bandMeansNames);
    var SegmentUnsupervised = afn_Kmeans(meanSegments,
        numberOfUnsupervisedClusters, defaultStudyArea,
        nativeScaleOfImage);
    Map.addLayer(SegmentUnsupervised.randomVisualizer(), {},
        '6.3 SNIC Clusters Unsupervised_' + date, 0, 1);
    // print('6.3b Per-Segment Unsupervised Results:', SegmentUnsupervised);
    
    
    if (centerObjectYN === true) {
        Map.centerObject(zoomArea, 14);
    } 
    
}

// First day
var date = '2017_10_03'
my_function(originalImage, date, ImageToUseID);

// Second day 
var date2 = '2017_10_04'
var originalImage2 = ee.Image('MODIS/006/MOD09GQ/2017_10_04');
var ImageToUseID2 = 'MOD09GQ2017_10_04';
my_function(originalImage2, date2, ImageToUseID2);

// Third day 
var date3 = '2017_10_05'
var originalImage3 = ee.Image('MODIS/006/MOD09GQ/2017_10_05');
var ImageToUseID3 = 'MOD09GQ2017_10_05';
my_function(originalImage3, date3, ImageToUseID3);

// Fourth day 
var date4 = '2017_10_06'
var originalImage4 = ee.Image('MODIS/006/MOD09GQ/2017_10_06');
var ImageToUseID4 = 'MOD09GQ2017_10_06';
my_function(originalImage4, date4, ImageToUseID4);



