
// Question: Assignment 1. Fit two NDVI harmonic models for a point close to Manaus, Brazil:
// one prior to a disturbance event and one after the disturbance event
// The disturbance event happened in mid-December 2014, so set filter dates for the first ImageCollection
// to ’2013-01-01’, ’2014-12-12’, and set the filter dates for the second
// ImageCollection to ‘2014-12-13’, ‘2019-01-01’. Merge both fitted collections and plot both NDVI and fitted values.

// Satellite basemap.
Map.setOptions('SATELLITE');

// Define roi, a point over the Brazilian Amazon.
var roi = ee.Geometry.Point([-59.985146, -2.871413]);

// Add the point to the map.
Map.addLayer(roi, {
    color: 'red'
  }, 'roi');
Map.centerObject(roi, 16);

// The dependent variable we are modeling.
var dependent = 'NDVI';

// The number of cycles per year to model.
var harmonics = 1;

// Make a list of harmonic frequencies to model.  
// These also serve as band name suffixes.
var harmonicFrequencies = ee.List.sequence(1, harmonics);

// Function to get a sequence of band names for harmonic terms.
var getNames = function(base, list) {
    return ee.List(list).map(function(i) {
        return ee.String(base).cat(ee.Number(i).int());
    });
};

// Construct lists of names for the harmonic terms.
var cosNames = getNames('cos_', harmonicFrequencies);
var sinNames = getNames('sin_', harmonicFrequencies);

// Independent variables.
var independents = ee.List(['constant', 't'])
    .cat(cosNames).cat(sinNames);

// Define function to mask clouds, scale, and add variables 
// (NDVI, time and a constant) to Landsat 8 imagery.
function maskScaleAndAddVariable(image) {
    // Bit 0 - Fill
    // Bit 1 - Dilated Cloud
    // Bit 2 - Cirrus
    // Bit 3 - Cloud
    // Bit 4 - Cloud Shadow
    var qaMask = image.select('QA_PIXEL').bitwiseAnd(parseInt('11111',
        2)).eq(0);
    var saturationMask = image.select('QA_RADSAT').eq(0);

    // Apply the scaling factors to the appropriate bands.
    var opticalBands = image.select('SR_B.').multiply(0.0000275).add(-
        0.2);
    var thermalBands = image.select('ST_B.*').multiply(0.00341802)
        .add(149.0);

    // Replace the original bands with the scaled ones and apply the masks.
    var img = image.addBands(opticalBands, null, true)
        .addBands(thermalBands, null, true)
        .updateMask(qaMask)
        .updateMask(saturationMask);
    var imgScaled = image.addBands(img, null, true);

    // Now we start to add variables of interest.
    // Compute time in fractional years since the epoch.
    var date = ee.Date(image.get('system:time_start'));
    var years = date.difference(ee.Date('1970-01-01'), 'year');
    var timeRadians = ee.Image(years.multiply(2 * Math.PI));
    // Return the image with the added bands.
    return imgScaled
        // Add an NDVI band.
        .addBands(imgScaled.normalizedDifference(['SR_B5', 'SR_B4'])
            .rename('NDVI'))
        // Add a time band.
        .addBands(timeRadians.rename('t'))
        .float()
        // Add a constant band.
        .addBands(ee.Image.constant(1));
}

// Function to compute the specified number of harmonics
// and add them as bands.  Assumes the time band is present.
var addHarmonics = function(freqs) {
    return function(image) {
        // Make an image of frequencies.
        var frequencies = ee.Image.constant(freqs);
        // This band should represent time in radians.
        var time = ee.Image(image).select('t');
        // Get the cosine terms.
        var cosines = time.multiply(frequencies).cos()
            .rename(cosNames);
        // Get the sin terms.
        var sines = time.multiply(frequencies).sin()
            .rename(sinNames);
        return image.addBands(cosines).addBands(sines);
    };
};

// Import the USGS Landsat 8 Level 2, Collection 2, Tier 1 image collection),
// and map functions.
var harmonicLandsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
    .filterBounds(roi)
    .map(maskScaleAndAddVariable)
    .map(addHarmonics(harmonicFrequencies));

// Filter dates     
var preImage = harmonicLandsat.filterDate('2013-01-01', '2014-12-12');
var postImage = harmonicLandsat.filterDate('2014-12-13', '2019-01-01');

// The output of the regression reduction is a 4 x 1 matrix
var preImgHarmTrend = preImage
    .select(independents.add(dependent))
    .reduce(ee.Reducer.linearRegression(independents.length(), 1));

// Turn the array image into a multi-band image of coefficients.
var preImgHarmTrendCoefficients = preImgHarmTrend.select('coefficients')
    .arrayProject([0])
    .arrayFlatten([independents]);

// Compute fitted values.
var preImgfittedHarmonic = preImage.map(function(image) {
    return image.addBands(
        image.select(independents)
        .multiply(preImgHarmTrendCoefficients)
        .reduce('sum')
        .rename('fitted'));
});

// Plot the fitted model and the original data at the ROI.
print(ui.Chart.image.series(
        preImgfittedHarmonic.select(['fitted', 'NDVI']), roi, ee.Reducer.mean(), 30)
    .setOptions({
        title: 'Harmonic model for period before disturbance event',
        lineWidth: 1,
        pointSize: 3,
    }));

//----> Do the same for the timeperiod after the disturbance event

// The output of the regression reduction is a 4 x 1 matrix
var postImgHarmTrend = postImage
    .select(independents.add(dependent))
    .reduce(ee.Reducer.linearRegression(independents.length(), 1));

// Turn the array image into a multi-band image of coefficients.
var postImgHarmTrendCoefficients = postImgHarmTrend.select('coefficients')
    .arrayProject([0])
    .arrayFlatten([independents]);

// Compute fitted values.
var postImgfittedHarmonic = postImage.map(function(image) {
    return image.addBands(
        image.select(independents)
        .multiply(postImgHarmTrendCoefficients)
        .reduce('sum')
        .rename('fitted'));
});

// Plot the fitted model and the original data at the ROI.
print(ui.Chart.image.series(
        postImgfittedHarmonic.select(['fitted', 'NDVI']), roi, ee.Reducer.mean(), 30)
    .setOptions({
        title: 'Harmonic model for period after disturbance event',
        lineWidth: 1,
        pointSize: 3,
    }));

// Merge the image collections for visualizations
var fitharm = preImgfittedHarmonic.merge(postImgfittedHarmonic);
print(fitharm);

// Plot the fitted model and the original data at the ROI.
print(ui.Chart.image.series(
        fitharm.select(['fitted', 'NDVI']), roi, ee.Reducer.mean(), 30)
    .setOptions({
        title: 'Harmonic model for period before and after disturbance event',
        lineWidth: 1,
        pointSize: 3,
    }));
    
//---> How does the harmonic model look if the model is fitted to the entire period?

harmonicLandsat = harmonicLandsat.filterDate('2013-01-01', '2019-01-01');

// The output of the regression reduction is a 4x1 array image.
var harmonicTrend = harmonicLandsat
    .select(independents.add(dependent))
    .reduce(ee.Reducer.linearRegression(independents.length(), 1));

// Turn the array image into a multi-band image of coefficients.
var harmonicTrendCoefficients = harmonicTrend.select('coefficients')
    .arrayProject([0])
    .arrayFlatten([independents]);

// Compute fitted values.
var fittedHarmonic = harmonicLandsat.map(function(image) {
    return image.addBands(
        image.select(independents)
        .multiply(harmonicTrendCoefficients)
        .reduce('sum')
        .rename('fitted'));
});

// Plot the fitted model and the original data at the ROI.
print(ui.Chart.image.series(
        fittedHarmonic.select(['fitted', 'NDVI']), roi, ee.Reducer
        .mean(), 30)
    .setOptions({
        title: 'Harmonic model fitted for the entire period',
        lineWidth: 1,
        pointSize: 3,
    }));