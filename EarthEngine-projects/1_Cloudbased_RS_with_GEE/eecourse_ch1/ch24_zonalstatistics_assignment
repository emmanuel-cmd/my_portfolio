// Question 1. Look at the MODIS example (Sect. 24.2.3.2), which uses the
// median reducer. Try modifying the reducer to be unweighted, either by specifying
// unweighted or by using an identifier reducer like max. What happens and why?

// This function returns a function for adding a buffer to a point
// and optionally transforming to rectangular bounds
function bufferPoints(radius, bounds) {
  return function(pt) {
    pt = ee.Feature(pt);
    return bounds ? pt.buffer(radius).bounds() : pt.buffer(radius);
  };
} 

// Function for zonal statistics

function zonalStats(ic, fc, params) {
  // Initialize internal params dictionary.
  var _params = {
     reducer: ee.Reducer.mean(),
     scale: null,
     crs: null,
     bands: null,
     bandsRename: null,
     imgProps: null,
     imgPropsRename: null,
     datetimeName: 'datetime',
     datetimeFormat: 'YYYY-MM-dd HH:mm:ss'
  };
  
  // Replace initialized params with provided params.
  if (params) {
  for (var param in params) {
     _params[param] = params[param] || _params[param];
   }
  }
  
  // Set default parameters based on an image representative.
  var imgRep = ic.first();
  var nonSystemImgProps = ee.Feature(null)
   .copyProperties(imgRep).propertyNames();
  if (!_params.bands) _params.bands = imgRep.bandNames();
  if (!_params.bandsRename) _params.bandsRename = _params.bands;
  if (!_params.imgProps) _params.imgProps = nonSystemImgProps;
  if (!_params.imgPropsRename) _params.imgPropsRename = _params.imgProps;
  
  // Map the reduceRegions function over the image collection.
  var results = ic.map(function(img) {
  
    // Select bands (optionally rename), set a datetime & timestamp property.
    img = ee.Image(img.select(_params.bands, _params.bandsRename))
    
    // Add datetime and timestamp features.
   .set(_params.datetimeName, img.date().format(_params.datetimeFormat))
   .set('timestamp', img.get('system:time_start'));
    
    // Define final image property dictionary to set in output features.
    var propsFrom = ee.List(_params.imgProps).cat(ee.List([_params.datetimeName, 'timestamp']));
    var propsTo = ee.List(_params.imgPropsRename)
    .cat(ee.List([_params.datetimeName, 'timestamp']));
    var imgProps = img.toDictionary(propsFrom).rename(propsFrom, propsTo);
    
    // Subset points that intersect the given image.
    var fcSub = fc.filterBounds(img.geometry());
    
    // Reduce the image by regions.
    return img.reduceRegions({
       collection: fcSub,
       reducer: _params.reducer,
       scale: _params.scale,
       crs: _params.crs
     })
    
    // Add metadata to each feature.
   .map(function(f) {
      return f.set(imgProps);
    });
    
  // Converts the feature collection of feature collections to a single
  // feature collection.
   }).flatten();
  return results;
} 


var pts = ee.FeatureCollection([
  ee.Feature(ee.Geometry.Point([-118.6010, 37.0777]), {
    plot_id: 1
  }),
  ee.Feature(ee.Geometry.Point([-118.5896, 37.0778]), {
    plot_id: 2
  }),
  ee.Feature(ee.Geometry.Point([-118.5842, 37.0805]), {
    plot_id: 3
  }),
  ee.Feature(ee.Geometry.Point([-118.5994, 37.0936]), {
    plot_id: 4
  }),
  ee.Feature(ee.Geometry.Point([-118.5861, 37.0567]), {
    plot_id: 5
  })
]);

// print('Points of interest', pts); 

// Buffer the points
var ptsModis = pts.map(bufferPoints(50, true));

// Calculate zonal statistics
var modisCol = ee.ImageCollection('MODIS/006/MOD09A1')
    .filterDate('2015-01-01', '2020-01-01')
    .filter(ee.Filter.calendarRange(183, 245, 'DAY_OF_YEAR')); 

// Define parameters for the zonalStats function.
var params = {
    reducer: ee.Reducer.max(),
    scale: 500,
    crs: 'EPSG:5070',
    bands: ['sur_refl_b01', 'sur_refl_b02', 'sur_refl_b06'],
    bandsRename: ['modis_red', 'modis_nir', 'modis_swir'],
    datetimeName: 'date',
    datetimeFormat: 'YYYY-MM-dd'
};

// Extract zonal statistics per point per image.
var ptsModisStats = zonalStats(modisCol, ptsModis, params);
print('Limited MODIS zonal stats table', ptsModisStats.limit(50));


// Q2: 

// Define point geometry.
var my_point = pts.limit(1);

// Buffer the point
var mypModis = my_point.map(bufferPoints(500, true));

// // Get the first MODIS image
// var myModis = modisCol.first();

// Define desired scale and crs for region reduction (for image display too).
var proj = {
  scale: 90,
  crs: 'SR-ORG:6974'
};

// A count reducer will return how many pixel centers are overlapped by the
// polygon region.
var count = modisCol.first().reduceRegion({
  reducer: ee.Reducer.mean().combine({
    reducer2: ee.Reducer.stdDev(),
    sharedInputs: true
  }).combine({
    reducer2: ee.Reducer.max(),
    sharedInputs: true
  }).combine({
    reducer2: ee.Reducer.min(),
    sharedInputs: true
  }),
  geometry: mypModis,
  scale: proj.scale,
  crs: proj.crs
});

print('n pixels in the reduction', count);


